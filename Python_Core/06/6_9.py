"""Дані у пам'яті комп'ютера зберігаються у вигляді послідовності байтів. Відповідно, будь-які дані можна подати у вигляді послідовності байтів. Для роботи з "сирими" даними в Python є два типи даних: bytes та bytearray.

Дуже багато протоколів досі працюють із "сирими" даними або просто потоком байтів, наприклад TCP/IP, послідовний порт, telnet і багато інших.

Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків (bytes) та масиви байтів bytearray.

BYTES
За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується суворо один байт.

Байт — це одиниця зберігання та обробки цифрової інформації, що містить 8 біт інформації. Один біт — це 0 або 1. За допомогою одного байта можна записати будь-яке число від 0 до 255 включно.

Для байт-рядків застосовні ті ж обмеження і правила, що і для звичайних рядків:

байт-рядки — незмінні;
байт-рядки — послідовні і до їх елементів можна звертатися по індексу:
  s = b'Hello!'
  print(s[1])  # b'e'
байт-рядки підтримують більшість методів рядків, таких як upper, startswith, index, find та інші.
Створення байт-рядків
byte_string = b'Hello world!'
В цьому прикладі у byte_string міститься послідовність символів по одному байту на кожного. Від оголошення звичайного рядка байт-рядок відрізняє наявність символу b перед самим рядком.

Другий спосіб створення байт рядків — це перетворення у байт-рядок.

Для перетворення рядка у байт-рядок можна скористатися методом рядків encode:

byte_str = 'some text'.encode()
У byte_str буде записана послідовність байтів.

В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у байт-рядок за допомогою функції bytes:

numbers = [0, 128, 255]
byte_numbers = bytes(numbers)
КОДУВАННЯ РЯДКІВ (ASCII, UTF-8, CP1251)
Перші комп'ютери для роботи з текстом використали так зване ASCII кодування. У цьому кодуванні для запису одного символу використовується один байт.

Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому кодуванні. ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. Але з часом алфавіту з 256 символів стало мало, виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют, ієрогліфи та ін.). Щоб задовольнити потребу в додаванні нових символів, придумали використати кодування, де більше за одного байту на символ. Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт, і всього в алфавіті може бути до 1 112 064 знаків. Це не єдине кодування, на різних платформах можуть бути присутні власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 і інші.

Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).

Наприклад, символ 'a' кодується числом 97:

ord('a')  # 97
Зворотна операція, коли треба дізнатися, що за символ закодований числом, наприклад 128, є функція chr (скорочено від character):

chr(128)  # 'd'
Python може працювати з дуже великою кількістю різних кодувань.

s = "Привет!"

utf8 = s.encode()
print(utf8)  # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82!'

utf16 = s.encode('utf-16')
print(utf16)  # b'\xff\xfe\x1f\x04@\x048\x042\x045\x04B\x04!\x00'

s_from_utf16 = utf16.decode('utf-16')
print(s_from_utf16 == s)  # True
Спроба перетворити байт-рядок в неправильному кодуванні приводить або до помилки, або до досить непередбачуваного результату:

print(b'Hello world!'.decode('utf-16'))  # 效汬潷汲Ⅴ
ПОРІВНЯННЯ РЯДКІВ
Порівняння рядків у Python може давати неоднозначний результат у наслідок того, що в UTF-8 кодуванні один і той же символ можна представити декількома кодами, наприклад символ 'ê' можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. З цієї причини порівняння одного і того ж символу може повернути False із-за відмінностей в записі.

Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх необхідно нормалізувати за допомогою методу casefold, який повертає рядок, де всі символи у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису."""


"""Є два рядки у різних кодуваннях - "utf-8" та "utf-16". Нам необхідно зрозуміти, чи дорівнюються рядки між собою.

Реалізуйте функцію is_equal_string(utf8_string, utf16_string), яка повертає True, якщо рядки дорівнюють собі, і False — якщо ні."""


def is_equal_string(utf8_string, utf16_string):

    decoded_utf8 = utf8_string.decode('utf-8')
    decoded_utf16 = utf16_string.decode('utf-16')

    
    return decoded_utf8 == decoded_utf16